---
layout: single
title:  "[t101-3기] Terraform 스터디 4주차 (1/2)"
tags:
  - terraform

categories:
  - terraform
    
toc: true
toc_sticky: true
---

## 1. State
###  State의 목적과 의미
- **상태 파일**은 배포할 때마다 변경되는 **프라이빗 API** *private API*로, 오직 테라폼 내부에서 사용하기 위한 것
- **테라폼 상태 파일**을 **직접 편집하거나 직접 읽는 코드로 작성해서는 안됩**니다.

`팀 단위에서 테라폼 운영 시 문제점`

1. 상태 파일을 저장하는 **공유 스토리지** *Shared storage for state files*
    - 각 팀원이 **동일한 테라폼 상태 파일 사용**을 위해서, 공유 위치에 저장이 필요
2. 상태 **파일 잠금** *Locking state files*
    - 잠금 기능 없이 두 팀원이 동시에 테라폼 실행 시 여러 테라폼 프로세스가 상태 파일을 동시에 업데이트하여 **충돌 가능**(경쟁 상태 *race condition*)
3. 상태 **파일 격리** *Isolating state files*
    - 예를 들면 테스트 *dev* 와 검증 *stage* 과 상용 *prodction* **각 환경에 대한 격리**가 필요

`상태 파일 공유로 버전 관리 시스템 비추천`

1. **수동 오류** *Manual error*
    - 테라폼을 실행하기 전에 최신 변경 사항을 가져오거나 실행하고 나서 push 하는 것을 잊기 쉽습니다(?).
    - 팀의 누군가가 이전 버전의 상태 파일로 테라폼을 실행하고, 그 결과 실수로 이전 버전으로 롤백하거나 이전에 배포된 인프라를 복제하는 문제가 발생 할 수 있음.
2. **잠금** *Locking*
    - 대부분의 버전 관리 시스템(VCS)은 여러 명의 팀 구성원이 동시에 하나의 상태 파일에 terraform apply 명령을 실행하지 못하게 하는 잠금 기능이 제공되지 않음.
3. **시크릿** *Secrets*
    - 테라폼 상태 파일의 모든 데이터는 평문으로 저장됨. 민감 정보가 노출될 위험.

`지원되는 원격 백엔드` : AWS S3, Azure Blob Storage, Google Cloud Storage, Consul, Postgres database 등 - [링크](https://developer.hashicorp.com/terraform/language/settings/backends/local) 

1. 수동 오류 해결 : plan/apply 실행 시 마다 해당 백엔드에서 파일을 자동을 로드, apply 후 상태 파일을 백엔드에 자동 저장
2. 잠금(Lock) : apply 실행 시 테라폼은 자동으로 잠금을 활성화, -lock-timout=<TIME> 로 대기 시간 설정 지정 가능
3. 시크릿 : 대부분 원격 백엔드는 기본적으로 데이터를 보내거나 상태 파일을 저장할 때 암호화(Encryption)하는 기능을 지원
  
- **소개 및 확인** : 테라폼은 **Stateful** 애플리케이션. 프로비저닝 결과 State를 저장하고 추적에 활용
    - **개인** 1인 : 로컬 환경으로 terraform.tfstate 파일에 JSON 형태로 저장
    - **팀이나 조직** : 공동 관리를 위해 **원격 저장소**에 저장해 공유 - [링크](https://developer.hashicorp.com/terraform/language/settings/backends/remote)
    - State에는 작업자가 정의한 코드와 실제 반영된 프로비저닝 결과를 저장하고, 이 정보를 토대로 이후의 리소스 생성, 수정, 삭제에 대한 동작 판단 작업을 수행
  
  **State 역할**

- State에는 테라폼 구성과 실제를 동기화하고 각 리소스에 고유한 아이디(리소스 주소)로 맵핑
- 리소스 종속성과 같은 메타데이터를 저장하고 추적
- 테라폼 구성으로 프로비저닝 결과를 캐싱하는 역할을 수행
  
  - 테라폼에서는 JSON 형태로 작성된 **State**를 통해 **속성**과 **인수**를 읽고 확인할 수 있다. 
테라폼에서는 **type**과 **name**으로 고유한 **리소스**를 **분류**하며, 해당 리소스의 **속성**과 **인수**를 구성과 비교해 **대상 리소스**를 **생성, 수정, 삭제**한다.
- State는 테라폼만을 위한 API로 정의할 수도 있다. **Plan**을 실행하면 암묵적으로 **refresh** 동작을 수행하면서 리소스 생성의 대상(클라우드 등)과 **State**를 기준으로 **비교**하는 과정을 거친다. 
이 작업은 프로비저닝 대상의 응답 속도와 기존 작성된 State의 리소스 양에 따라 속도 차이가 발생한다. 대량의 리소스를 관리해야 하는 경우 Plan 명령에서 `-refresh=false` 플래그를 사용해 State를 기준으로 실행 계획을 생성하고, 이를 실행에 활용해 대상 환경과의 동기화 과정을 생략할 수 있다.
  
```
resource "random_password" "mypw" {
  length           = 16
  special          = true
  override_special = "!#$%"
}
```
  
```
terraform init && terraform plan
terraform apply -auto-approve

# State List 및 생성된 Password 확인
terraform state list
terraform state show random_password.mypw
---
  random_password.mypw
# random_password.mypw:
resource "random_password" "mypw" {
    bcrypt_hash      = (sensitive value)
    id               = "none"
    length           = 16
    lower            = true
    min_lower        = 0
    min_numeric      = 0
    min_special      = 0
    min_upper        = 0
    number           = true
    numeric          = true
    override_special = "!#$%"
    result           = (sensitive value)
    special          = true
    upper            = true
}
---
```
  
- State에 저장된 result를 확인해보자! -> 어떻게 관리해야할까요?
```
ls *.tfstate
cat terraform.tfstate | jq
cat terraform.tfstate | jq | grep result

  "result": "ednRVV8r%!dd$7y3",
  "check_results": null

# (참고) sensitive value 내용은 테라폼 콘솔에서 보일까요? (정답: x)
echo "random_password.mypw" | terraform console
echo "random_password.mypw.result" | terraform console
```
  
  - 테라폼에서는 JSON 형태로 작성된 **State**를 통해 **속성**과 **인수**를 읽고 확인할 수 있다. 
테라폼에서는 **type**과 **name**으로 고유한 **리소스**를 **분류**하며, 해당 리소스의 **속성**과 **인수**를 구성과 비교해 **대상 리소스**를 **생성, 수정, 삭제**한다.
- State는 테라폼만을 위한 API로 정의할 수도 있다. **Plan**을 실행하면 암묵적으로 **refresh** 동작을 수행하면서 리소스 생성의 대상(클라우드 등)과 **State**를 기준으로 **비교**하는 과정을 거친다. 
이 작업은 프로비저닝 대상의 응답 속도와 기존 작성된 State의 리소스 양에 따라 속도 차이가 발생한다. 대량의 리소스를 관리해야 하는 경우 Plan 명령에서 `-refresh=false` 플래그를 사용해 State를 기준으로 실행 계획을 생성하고, 이를 실행에 활용해 대상 환경과의 동기화 과정을 생략할 수 있다.
  
 ## 2. State 동기화
 ![](https://velog.velcdn.com/images/yuran3391/post/eb638424-102f-4984-ad48-c2cf770f7a25/image.png)

## 3 워크스페이스
  
  1. **작업 공간을 통한 격리** Isolation via **workspaces**
    - 동일한 구성에서 빠르고 격리된 테스트 환경에 유용
    - 논리적 격리 가능
2. **파일 레이아웃을 이용한 격리** Isolation via **file layout**
    - 보다 **강력하게 분리해야** 하는 운영 환경에 적합
    - 테라폼 프로젝트의 **파일 레이아웃 설명**
        - 각 테라폼 **구성 파일**을 분리된 폴더에 넣기. (예. stage , prod)
        - 각 환경에 서로 **다른 백엔드** 구성. (예. S3 버킷 백엔드의 AWS 계정을 분리)
  
  `최상위 폴더`

- **stage** : 테스트 환경과 같은 사전 프로덕션 워크로드 workload 환경
- **prod** : 사용자용 맵 같은 프로덕션 워크로드 환경
- **mgmt** : 베스천 호스트 Bastion Host, 젠킨스 Jenkins 와 같은 데브옵스 도구 환경
- **global** : S3, IAM과 같이 **모든 환경에서 사용되는 리소스**를 배치

`각 환경별 구성 요소`

- **vpc** : 해당 환경을 위한 네트워크 토폴로지
- **services** : 해당 환경에서 서비스되는 애플리케이션, 각 앱은 자체 폴더에 위치하여 다른 앱과 분리
- **data-storage** : 해당 환경 별 데이터 저장소. 각 데이터 저장소 역시 자체 폴더에 위치하여 다른 데이터 저장소와 분리
