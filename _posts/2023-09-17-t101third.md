---
layout: single
title:  "[t101-3기] Terraform 스터디 3주차"
tags:
  - terraform

categories:
  - terraform
    
toc: true
toc_sticky: true
---

본 시리즈는 T101(테라폼으로 시작하는 IaC) 3기 스터디 진행 내용입니다. 
테라폼으로 시작하는 IaC 책을 기반으로 내용 정리하였습니다.

![](https://image.yes24.com/goods/119179333/XL) 

[도서정보](https://www.yes24.com/Product/Goods/119179333)

[실습 코드](https://github.com/terraform101)


## 반복문
### Count
- 정의: list 형태의 값 목록이나 Key-Value 형태의 문자열 집합인 데이터가 있는 경우 동일한 내용에 대해 테라폼 구성 정의를 반복적으로 하지 않고 관리할 수 있다.

- count : 리소스 또는 모듈 블록에 count 값이 정수인 인수가 포함된 경우 선언된 정수 값만큼 리소스나 모듈을 생성하게 된다.


```bash
resource "local_file" "abc" {
  count    = 5 # 
  content  = "abc"
  filename = "${path.module}/abc.txt"
}

output "filecontent" {
  value = local_file.abc.*.content
}

output "fileid" {
  value = local_file.abc.*.id
}

output "filename" {
  value = local_file.abc.*.filename
}
```
- 실행 후 확인 : 5개의 파일이 생성되어야 하지만 파일명이 동일하여 결과적으로 하나의 파일만 존재 ← count 사용 시 주의!!> count.index 활용!
```
terraform init && terraform apply -auto-approve
terraform state list
echo "local_file.abc[0]" | terraform console
ls *.txt


terraform output
# terraform output filename
# terraform output fileid
# terraform output filecontent
```
- count에서 생성되는 참조 값은 count.index이며, 반복하는 경우 0부터 1씩 증가해 인덱스가 부여된다.
- 여러개 파일 생성을 위해 아래 코드로 테레폼 코드 변경
```
   content  = "abc${count.index}"
```

때때로 여러 리소스나 모듈의 count로 지정되는 수량이 동일해야 하는 상황이 있다. 이 경우 count에 부여되는 정수 값을 외부 변수에 식별되도록 구성할 수 있다.

ist 형태의 배열을 활용한 반복문 동작 구성

```
variable "names" {
  type    = list(string)
  default = ["a", "b", "c"]
}

resource "local_file" "abc" {
  count   = length(var.names)
  content = "abc"
  # 변수 인덱스에 직접 접근
  filename = "${path.module}/abc-${var.names[count.index]}.txt"
}

resource "local_file" "def" {
  count   = length(var.names)
  content = local_file.abc[count.index].content
  # element function 활용
  filename = "${path.module}/def-${element(var.names, count.index)}.txt"
}
```
local_file.def의 경우 local_file.abc와 개수가 같아야 content에 선언되는 인수 값에 오류가 없을 것이므로 서로 참조되는 리소스와 모듈의 반복정의에 대한 공통의 영향을 주는 변수로 관리할 수 있다.

- count로 생성되는 리소스의 경우 <리소스 타입>.<이름>[<인덱스 번호>], 모듈의 경우 module.<모듈 이름>[<인덱스 번호>]로 해당 리소스의 값을 참조한다.
- 단, 모듈 내에 count 적용이 불가능한 선언이 있으므로 주의해야 한다.
    - 예를 들어 provider 블록 선언부가 포함되어 있는 경우에는 count 적용이 불가능하다 → provider 분리
    - **또한 외부 변수가 list 타입인 경우 중간에 값이 삭제되면 인덱스가 줄어들어 의도했던 중간 값에 대한 리소스만 삭제되는 것이 아니라 이후의 정의된 리소스들도 삭제되고 재생성된다**.
    
### for_each 
반복문, 선언된 key 값 개수만큼 리소스를 생성
- 리소스 또는 모듈 블록에서 for_each에 입력된 데이터 형태가 map 또는 set이면, 선언된 key 값 개수만큼 리소스를 생성하게 된다.
```
resource "local_file" "abc" {
  for_each = {
    a = "content a"
    b = "content b"
  }
  content  = each.value
  filename = "${path.module}/${each.key}.txt"
}
```
- for_each가 설정된 블록에서는 each 속성을 사용해 구성을 수정할 수 있다
    - **each.key** : 이 인스턴스에 해당하는 map 타입의 key 값
    - **each.value** : 이 인스턴스에 해당하는 map의 value 값
- 생성되는 리소스의 경우 <리소스 타입>.<이름>[<key>], 모듈의 경우 module.<모듈 이름>[<key>]로 해당 리소스의 값을 참조한다.
- 이 참조 방식을 통해 리소스 간 종속성을 정의하기도 하고 변수로 다른 리소스에서 사용하거나 출력을 위한 결과 값으로 사용한다.
- **main.tf** 파일 수정 : local_file.abc는 변수의 map 형태의 값을 참조, local_file.def의 경우 local_file.abc 도한 결과가 map으로 반환되므로 다시 for_each 구문을 사용할 수 있다

```
variable "names" {
  default = {
    a = "content a"
    b = "content b"
    c = "content c"
  }
}

resource "local_file" "abc" {
  for_each = var.names
  content  = each.value
  filename = "${path.module}/abc-${each.key}.txt"
}

resource "local_file" "def" {
  for_each = local_file.abc
  content  = each.value.content
  filename = "${path.module}/def-${each.key}.txt"
}
```
  ## 조건문
  테라폼에서의 조건식은 3항 연산자 형태를 갖는다. 조건은 true 또는 false로 확인되는 모든 표현식을 사용할 수 있다 
  
  - 일반적으로 비교, 논리 연산자를 사용해 조건을 확인한다.
- 조건식은 **?** 기호를 기준으로 **왼쪽**은 **조건**이며, **오른쪽**은 **:** 기호를 기준으로 **왼쪽**이 조건에 대해 **true**가 반환되는 경우이고 **오른쪽**이 **false**가 반환되는 경우다.
- 다음의 예에서 var.a가 빈 문자열이 아니라면 var.a를 나타내지만, 비어 있을 때는 “default-a”를 반환한다
  
```
# <조건 정의> ? <옳은 경우> : <틀린 경우>
var.a != "" ? var.a : "default-a"
```
  조건식의 각 조건은 비교 대상의 형태가 다르면 테라폼 실행 시 조건 비교를 위해 형태를 추론하여 자동으로 변환하는데, 명시적인 형태 작성을 권장
  
  
```
var.example ? 12 : "hello"            # 비권장
var.example ? "12" : "hello"          # 권장
var.example ? tostring(12) : "hello"  # 권장
```
- 예제
  
```
  variable "enable_file" {
  default = true
}

resource "local_file" "foo" {
  count    = var.enable_file ? 1 : 0
  content  = "foo!"
  filename = "${path.module}/foo.bar"
}

output "content" {
  value = var.enable_file ? local_file.foo[0].content : ""
}
```
  
 ### [도전과제1] 
 조건문을 활용하여 (각자 편리한) AWS 리소스를 배포하는 코드를 작성해보자! 
  
```
variable "create_vpc" {
  description = "Set to true to create the VPC, false to skip."
  type        = bool
  default     = true
}
  
# AWS provider 설정
provider "aws" {
  region = "ap-northeast-2" 
}

# VPC 리소스 정의
resource "aws_vpc" "yuran_vpc" {
  count = var.create_vpc ? 1 : 0
  cidr_block = "10.0.0.0/16"
  enable_dns_support = true
  enable_dns_hostnames = true
  tags = {
    Name = "yuranVPC"
  }
}

# 서브넷 리소스 정의
resource "aws_subnet" "yuran_subnet" {
  count = var.create_vpc ? 1 : 0
  vpc_id     = aws_vpc.yuran_vpc[0].id
  cidr_block = "10.0.0.0/24"
  availability_zone = "ap-northeast-2" 
  tags = {
    Name = "yuranSubnet"
  }
}

```
