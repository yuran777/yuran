---
layout: single
title:  "프런트엔드와 배치 애플리케이션 빌드와 배포"
---
---
title: "API 애플리케이션 빌드와 배포"
type: single
tags:
  - aws
categories:
  - aws
---
완성 아키텍처 
![](https://images.velog.io/images/yuran3391/post/8b768966-6a99-4f93-a75e-4cf139d4cda6/aws-3.jpg)

- 본 포스팅은 클라우드 네이티브를 위한 쿠버네티스 실전 프로젝트 내용을 기반으로 작성 되었습니다.
- 소스 코드를 아래 깃헙에서 다운 받은 후 작업해주세요.https://github.com/yuran777/k8s-aws-book.git

## 4. API 애플리케이션 빌드와 배포 
### 4.1 필요 도구 준비
- AWS에서 애플리케이션을 동작시키기에 AWS 친화적인 오픈JDK인 Amazon Cooretto를 설치합니다.
- 자바 버전은 LTS 버전인 11을 이용합니다.
- 컨테이너 이미지를 푸시하기 위헤 도커데스크톱을 설치합니다.

#### 4.1.1 Amazon Corretto 11 다운로드
https://docs.aws.amazon.com/ko_kr/corretto/latest/corretto-11-ug/macos-install.html
위 링크 가이드에 따라 다운 후 java -version, javac -version 명령어로 잘 설치 되었는지 확인해 봅니다.
~~~bash
java -version

openjdk version "11.0.14.1" 2022-02-08 LTS
OpenJDK Runtime Environment Corretto-11.0.14.10.1 (build 11.0.14.1+10-LTS)
OpenJDK 64-Bit Server VM Corretto-11.0.14.10.1 (build 11.0.14.1+10-LTS, mixed mode)

javac -version
javac 11.0.14.1
~~~
#### 4.1.2 JAVA_HOME 환경 변수 설정
Amazon Corretto 설치 작업이 끝났다면 마지막으로 JAVA_HOME 환경 변수를 설정합니다.
~~~bahs
echo 'export JAVA_HOME=$(/usr/libexec/java_home -v 11)' >> ~/.zprofile
~~~


#### 4.1.3 도커 데스크톱 다운로드
아래 사이트에서 다운 받은 후
https://www.docker.com/products/docker-desktop

docker version 명령어를 통해 잘 설치 되었는지 확인해 봅니다.
~~~bash
docker version                  
Client:
 Cloud integration: v1.0.22
 Version:           20.10.12
 API version:       1.41
 Go version:        go1.16.12
 Git commit:        e91ed57
 Built:             Mon Dec 13 11:46:56 2021
 OS/Arch:           darwin/amd64
 Context:           default
 Experimental:      true

Server: Docker Desktop 4.5.0 (74594)
 Engine:
  Version:          20.10.12
  API version:      1.41 (minimum version 1.12)
  Go version:       go1.16.12
  Git commit:       459d0df
  Built:            Mon Dec 13 11:43:56 2021
  OS/Arch:          linux/amd64
  Experimental:     false
 containerd:
  Version:          1.4.12
  GitCommit:        7b11cfaabd73bb80907dd23182b9347b4245eb5d
 runc:
  Version:          1.0.2
  GitCommit:        v1.0.2-0-g52b36a2
 docker-init:
  Version:          0.19.0
  GitCommit:        de40ad0
~~~


### 4.2 소스 코드 빌드와 컨테이너 이미지 생성
#### 4.2.1 소스 코드 빌드

소스 코드 빌드네는 자바 애플리케이션용 빌드 도구인 그래들을 이용합니다. 그래들은 기본적으로 독립된 도구로 설치해서 사용하지만, 그래들 래퍼라는 구조를 사용하면 그래들이 미설치된 환경에서도 필요한 라이브러리를 자동적으로 다운로드하고 빌드할 수 있습니다.

```bash
cd <위에 깃헙 링크를 통해 다운받은 파일의 위치>/backend-app
sudo chmod 755 ./gradlew
./gradlew clean build
```

위의 명령어를 실행하여 정상적으로 빌드 되면 콘솔에 'BUILD SUCCESSFUL'이라고 표시되며 다음 작업이 수행됨
- 의존성 라이브러리 다운로드
- 프로그램 컴파일
- 테스트 프로그램 컴파일
- 테스트 실행
- 프로그램 실행용 아카이브 파일 생성

또한, Bckend-app/build/libs/backend-app-1.0.0.jar 파일이 생성됨

#### 4.2.2 컨테이너 이미지 생성
컨테이너 이미지를 정의하는 dockerfile을 생성하고 docker build 명령어 사용

~~~bash
sudo docker build -t k8sbook/batch-app:1.0.0 --build-arg \
JAR_FILE=build/libs/batch-app-1.0.0.jar .
~~~

### 4.3 컨테이너 레지스트리 준비

aws management console > amazon container service > amazon ecr > '레포지토리 생성' 클릭

'리포지토리 이름' 항목에 k8sbook/backend-app (namespace/repo-name) 입력 후 클릭 클릭 해서 레포지토리 생성 

생성 시 
'<어카운트 id>.dkr.ecr.ap-northeast-2.amazonaws.com/k8sbook/backend-app' 형태의 레파지토리 주소가 생성되며 이는 컨테이너 이미지를 푸시/풀 할때 설정함



### 4.4 컨테이너 이미지 푸시

#### 4.4.1 ECR 로그인


~~~ bash
aws ecr get login-password --region ap-northeast-2 | \
docker login --username AWS --password-stdin \
<어카운트 id>.dkr.ecr.ap-northeast-2.amazonaws.com
~~~


#### 4.4.2 컨테이너 이미지 태그 설정과 푸시

4.4.1 과정을 통해 ecr에 로그인 되었다면 이제는 컨테이너 이미지를 이미지를 저장

- docker tag 명령으로 컨테이너 이미지에 태그 설정
- 해당 태그에 대해 docker push 명령 실행 

- docker tag 명령으로 컨테이너 이미지에 태그 설정

~~~bash
docker tag k8sbook/batch-app:1.0.0 <aws account id>.dkr.ecr.ap-northeast-2.amazonaws.com/yuran/batch-app:1.0.0
~~~


- 해당 태그에 대해 docker push 명령 실행 

~~~bash
docker push <aws account id>.dkr.ecr.ap-northeast-2.amazonaws.com/k8sbook/batch-app:1.0.0
~~~
실행하면 설정한 태그에 따라 ECR 컨테이너 이미지가 전송됨. 이렇게 API 어플리케이션 컨테이너 이미지가 ECR에 저장됨

### 4.5 EKS 클러스터에 API 애플리케이션 배포
#### 4.5.1네임스페이스 생성
- createnamespace.yaml
~~~yaml
apiVersion: v1
kind: Namespace
metadata:
  name: eks-work
~~~
~~~bash
kubectl apply -f createnamespace.yaml
~~~

- kubeconfig에 네임스페이스 반영
~~~bash
kubectl config set-context eks-work --cluster eks-work-cluster.ap-northeast-2.eksctl.io \
--user <AUTH INFO 값> \
--namespace eks-work

kubectl config get-contexts
~~~

- 데이터베이스 접속용 시크릿 등록

~~~bash
DB_URL=jdbc:postgresql://<RDS 엔드포인트 주소>myworkdb \
DB_PASSWORD='<DB사용자 주소>' \
envsubst < 21_db_config_k8s.yaml.template | \
kubectl apply -f -
~~~
21_db_config_k8s.yaml.template

~~~yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: backend-app
  labels:
    app: backend-app
spec:
  replicas: 2
  selector:
    matchLabels:
      app: backend-app
  template:
    metadata:
      labels:
        app: backend-app
    spec:
      containers:
      - name: backend-app
        image: ${ECR_HOST}/k8sbook/backend-app:1.0.0
        imagePullPolicy: Always
        ports:
        - containerPort: 8080
        env:
        - name: DB_URL
          valueFrom:
            secretKeyRef:
              key: db-url
              name: db-config
        - name: DB_USERNAME
          valueFrom:
            secretKeyRef:
              key: db-username
              name: db-config
        - name: DB_PASSWORD
          valueFrom:
            secretKeyRef:
              key: db-password
              name: db-config
        readinessProbe:
          httpGet:
            port: 8080
            path: /health
          initialDelaySeconds: 15
          periodSeconds: 30
        livenessProbe:
          httpGet:
            port: 8080
            path: /health
          initialDelaySeconds: 30
          periodSeconds: 30
        resources:
          requests:
            cpu: 100m
            memory: 512Mi
          limits:
            cpu: 250m
            memory: 768Mi
        lifecycle:
          preStop:
            exec:
              command: ["/bin/sh", "-c", "sleep 2"]
              ~~~
- API 애플리케이션 배포

~~~
ECR_HOST=<AWS 호스트>.dkr.ecr.ap-northeast-2.amazonaws.com
envsubst < 22_deployment_backend-app_k8s.yaml.template | \
pipe> kubectl apply -f -
~~~

- API 애플리케이션 외부 공개
~~~bash
kubectl apply -f 23_service_backend-app_k8s.yaml
~~~

~~~yaml
apiVersion: v1
kind: Service
metadata:
  name: backend-app-service
spec:
  type: LoadBalancer
  selector:
    app: backend-app
  ports:
  - protocol: TCP
    port: 8080
    targetPort: 8080
~~~
프런트엔드 애플리케이션 배포 빌드 및 배포 부터는 다음 포스팅에

## 5. 프런트엔드 애플리케이션 빌드와 배포

### 5.1 Node.js 설치
https://nodejs.org/en/ 에서 LTS버전 다운로드

### 5.2 프런트엔드 애플리케이션 빌드
~~~bash
# 프런트엔드 소스코드가 있는 디렉토리로 이동
cd k8s-aws-book/frontend-app
# 라이브러리 다운로드
npm install
~~~
#### 5.2.1 API 기본 URL 확인

~~~bash
kubectl get all 
NAME                          TYPE           CLUSTER-IP      EXTERNAL-IP                                                                   PORT(S)          AGE
service/backend-app-service   LoadBalancer   10.100.91.195   00000-175018810.ap-northeast-2.elb.amazonaws.com   8080:32543/TCP   5d3h
~~~
#### 5.2.2 빌드 실행
~~~bash
BASE_URL=<EXTERNAL-IP>8080 npm run build
~~~
빌드 결과 파일은 dist 디렉토리 아래에 출력됨
이 디렉토리를 웹 서버에 저장하면 프런트엔드 애플리케이션을 공개할 수 있음



### 5.3 S3 버킷과 CloudFront 배포 생성 

k8s-aws-book/eks-env/30_s3_cloudfront_cfn.yaml 로 스택 생성
스택 이름: eks-work-frontend
BucketSuffix: 마음대로

#### 5.3.1 콘텐츠 업로드
~~~bash
aws s3 sync dist s3://eks-work-frontend-yrkim \                                    ok  04:48:36 PM
--delete --include "*" --acl public-read
~~~
#### 5.3.2 CloudFront 배포 캐시 무효화
오래된 캐시가 보이지 않게 하기 위해 캐시 무효화를 한다
Distribution Id 값은 eks-work-frontend 스택의 출력 부분에서 확인 가능

~~~bash
aws cloudfront create-invalidation --distribution-id <Distribution ID값> \              INT  9s  04:52:22 PM
--path "/*"
~~~


![](https://images.velog.io/images/yuran3391/post/3dce06b5-c613-446f-aa54-4821aba99f55/image.png)

els-work-frontend 스택 부분 출력에 있는 cloudfront 주소로 테스트 페이지 접속 가능


## 6. 배치 애플리케이션 빌드와 배포
### 6.1 배치 애플리케이션 빌드와 컨테이너 이미지 생성
#### 6.1.1 소스 코드 빌드
~~~bash
cd k8sbook/batch-app
./gradlew clean build
~~~
코드 빌드 완료시 libs 아래 .jar 파일이 만들어짐 

#### 6.1.2 ECR 리포지터리 생성
이전에 backend 리포지터리 생성했을때와 동일하게 Amazon ECR>
리포지토리 > '리포지토리 생성'
리포지터리 이름: k8sbook/batch-app

### 6.2 컨테이너 이미지 푸시 
#### 6.2.1 ECR 로그인

로그인 한지 12시간이 되지 않았다면 할 필요 없음 
~~~bash
aws ecr get-login-password --region ap-northeast-2 | \                           ok  33s  05:09:59 PM
docker login --username AWS --password-stdin \
<aws_acount_id>.dkr.ecr.ap-northeast-2.amazonaws.com
~~~

#### 6.2.2 컨테이너 이미지 태그 생성과 푸시 
~~~bash
docker tag k8sbook/batch-app:1.0.0 <aws_acount_id>.dkr.ecr.ap-northeast-2.amazonaws.com/yuran/batch-app:1.0.0

docker push <aws_acount_id>.dkr.ecr.ap-northeast-2.amazonaws.com/yuran/batch-app:1.0.0 
~~~

### 6.3 s3 버킷 생성과 설정
#### 6.3.1 s3 버킷 생성과 설정
k8s-aws-book/eks-env/40_s3_batch_cfn.yaml 로 스택 생성
스택 이름: eks-work-batch
BucketSuffix: 마음대로

#### 6.3.2 s3 컨피그맵 생성
~~~bash
BUCKET_SUFFIX=eks-work-batch-yrkim \                                                 INT  05:21:23 PM
envsubst < 41_config_map_batch_k8s.yaml.template | kubectl apply -f -
~~~
#### 6.3.3 s3 접속용 액세스 키 확인 및 시크릿 생성
- 액세스 키 확인
AWS Systems Manager > 파라미터 스토어

- 시크릿 생성
~~~bash
AWS_ACCESSKEY=<액세스키> \                                INT  eks-work/eks-work kube  05:21:23 PM
AWS_SECRETKEY=<비밀 액세스키> \
envsubst < 42_batch_secrets_k8s.yaml.template | kubectl apply -f -
~~~



### 6.4 입력 파일 업로드 


~~~bash
aws s3 sync dist s3://eks-work-frontend-yrkim \                                      INT  05:26:37 PM
--delete --include "*" --acl public-read
~~~

### 6.5 배치 애플리케이션 배포
#### 6.5.1 DB 내용 확인
~~~bash

sh-4.2$ psql -U mywork -h <rds 엔드포인트 주소> myworkdb
Password for user mywork:
myworkdb=> select * from location limit 50;
 location_id |  location_name  | region_id |                                         note
-------------+-----------------+-----------+--------------------------------------------------------------------------------------
           1 | 테디베어 뮤지엄 |         9 | 테디베어의 역사는 물론 예술, 세계여행 등의 테마를 제공하는 테마 뮤지엄 브랜드입니다.
           2 | 성산 일출봉     |         9 | 유네스코 세계자연유산에 등재된 제주도의 랜드마크.
(2 rows)
~~~

#### 6.5.2 배치 애플리케이션 배포

크론잡 수행
~~~bash
ECR_HOST=<aws_account_id>.dkr.ecr.ap-northeast-2.amazonaws.com \           ok  eks-work/eks-work kube  05:38:13 PM
envsubst < 43_cronjob_k8s.yaml.template | \
kubectl apply -f -
~~~

~~~bash
kubectl get all
NAME                      SCHEDULE      SUSPEND   ACTIVE   LAST SCHEDULE   AGE
cronjob.batch/batch-app   */5 * * * *   False     14       4m45s           69m
~~~
#### 6.5.2 배치 애플리케이션 실행 후 확인 

~~~bash

sh-4.2$ psql -U mywork -h <rds 엔드포인트 주소> myworkdb
Password for user mywork:
myworkdb=> select * from location limit 50;

~~~








